<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Friction Lab Simulation</title>
<style>
 :root{
    --primary:#007acc;
    --accent:#c00;
    --bg:#f7f7f7;
    --text:#333;
    --text-secondary:#444;
    --card-bg:#fff;
    --card-border:#e6e6e6;
    --card-shadow:rgba(0,0,0,0.1);
    --input-bg:#fff;
    --input-border:#ccc;
    --grid-major:#000;
    --grid-minor:#ccc;
    --grid-light:#eee;
    --vslider-space:48px;
 }
 :root.dark-mode{
    --primary:#5eb3ff;
    --accent:#ff8080;
    --bg:#0f0f0f;
    --text:#e8e8e8;
    --text-secondary:#c0c0c0;
    --card-bg:#1e1e1e;
    --card-border:#3a3a3a;
    --card-shadow:rgba(0,0,0,0.5);
    --input-bg:#2a2a2a;
    --input-border:#4a4a4a;
    --grid-major:#d0d0d0;
    --grid-minor:#505050;
    --grid-light:#3a3a3a;
 }
 *{box-sizing:border-box;}
 body{margin:0;font-family:"Segoe UI","Helvetica Neue",Arial,sans-serif;background:var(--bg);color:var(--text);overflow-y:scroll;transition:background-color 0.3s ease,color 0.3s ease;}
 h1{text-align:center;margin:12px 0 10px;font-size:1.6rem;line-height:1.1;color:var(--text);}
 .container{display:flex;flex-wrap:wrap;justify-content:center;align-items:stretch;gap:20px;max-width:1200px;margin:0 auto 28px;padding:0 15px;}
 .info-container{
    flex: 0 0 420px; /* Wider fixed width so controls fit on one line */
    display:flex;
    flex-direction:column;
    gap:20px;
 }
 .controls{
    display:flex;
    flex-direction:column;
    gap:16px;
    background: var(--card-bg);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px var(--card-shadow);
    width: 100%;
 }
 .controls-row{
    display:flex;
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
 }
/* inline-row used to place a label and control on the same line */
.inline-row{flex-direction:row;align-items:center;gap:12px;}
.inline-label{flex:0 0 auto;min-width:110px;font-weight:600;color:var(--text-secondary);}
.inline-select{flex:1 1 auto;max-width:320px;}
.inline-range{width:200px;}
 label{font-weight:600;color:var(--text-secondary);}
 select,input[type=range],input[type=number]{
    padding:6px 10px;
    font-size:1rem;
    border:1px solid var(--input-border);
    border-radius:4px;
    background:var(--input-bg);
    color:var(--text);
    width: 100%;
    box-sizing: border-box;
 }
 select {
    -webkit-appearance: none;
    appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 16px;
    padding-right: 35px;
 }
 :root.dark-mode select {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23e8e8e8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
 }
 .mass-controls {
    display: flex;
    align-items: center;
    gap: 12px;
    /* Removed light grey background so controls sit on white card */
    background: transparent;
    padding: 6px 8px; /* slightly smaller padding to match visual spacing */
    border-radius: 4px;
    width: 100%;
 }
 .mass-input {
    width: 80px !important;
    text-align: right;
    border: 1px solid var(--input-border);
    flex-shrink: 0;
 }
 input[type=range]{
    flex: 1;
    margin: 0;
    min-width: 0;
 }
 input[type=range] {
    accent-color: var(--primary);
 }
 /* Modern slider styling */
 input[type=range] {
    height: 8px;
    -webkit-appearance: none;
    background: #ddd;
    border-radius: 4px;
    padding: 0;
 }
 input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--primary);
    cursor: pointer;
    border: none;
    margin-top: -4px;
 }
 input[type=range]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--primary);
    cursor: pointer;
    border: none;
 }
 input[type=range]:focus {
    outline: none;
 }
.controls-row:has(button) {
    flex-direction: row;
    gap: 12px;
    align-items: center;
    justify-content: center; /* center the action buttons */
 }
button.action{
   padding: 12px 24px;
   font-size: 1rem;
   border: none;
   border-radius: 4px;
   color: #fff;
   cursor: pointer;
   transition: all 0.2s ease;
   flex: 0 0 auto;
   min-width: 140px;
   box-shadow: 0 3px 6px rgba(0,0,0,0.16);
   position: relative;
   top: 0;
 }
 button.action:hover {
    filter: brightness(1.1);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    top: -1px;
 }
 button.action:active {
    box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    top: 2px;
    filter: brightness(0.95);
 }
 #startBtn{
    background: #1a73e8;
    font-weight: 500;
 }
 #resetBtn{
    background: #dc3545; /* Red when enabled (simulation running) */
    transition: background 0.3s ease;
 }
 #resetBtn:disabled{
    background:#999; /* Grey when disabled */
    cursor:not-allowed;
    filter: none;
 }
 #startBtn:disabled{
    background:#999;
    cursor:not-allowed;
    filter: none;
 }
 .readout{
    background: var(--card-bg);
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px var(--card-shadow);
    display: flex;
    align-items: center;
    gap: 18px;
    min-height: 64px;
 }
 .readout-label {
    font-size: 0.875rem;
    color: var(--accent);
    font-weight: 500;
    margin: 0;
    white-space: nowrap;
 }
 #forceReadout {
    font-size: 2.1rem;
    color: var(--accent);
    text-align: left;
    letter-spacing: 0.5px;
    margin: 0;
 }
 .results{
    background: var(--card-bg);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px var(--card-shadow);
    font-size: 1.15rem;
    line-height: 1.45;
    min-height: 180px;
 }
 .results-heading {
    font-size: 1.25rem;
    color: var(--text);
    font-weight: 500;
    margin-bottom: 16px;
 }
 .awaiting-data {
    color: var(--text);
    opacity: 0.7;
    font-style: italic;
    text-align: center;
    padding: 20px 0;
 }
.results .result-row{
   display:flex;
   align-items:center;
   justify-content:space-between;
   padding:8px 0;
}
.results .result-label{
   flex:1 1 auto;
}
.results .result-value{
   flex:0 0 auto;
   color:var(--text);
   font-weight:600;
}
/* Custom coefficients row: show static and kinetic side-by-side and centered. Hidden by default; JS will toggle display. */
#customCoeffs{
   display:none;
   flex-direction:row;
   gap:18px;
   align-items:center;
   justify-content:center;
}
#customCoeffs label{display:flex;flex-direction:column;align-items:center;gap:6px;margin:0;}
#customCoeffs input[type=number]{width:80px !important;padding:8px;}
/* Theme toggle button */
.theme-toggle {
   position: fixed;
   bottom: 20px;
   right: 20px;
   width: 50px;
   height: 50px;
   border-radius: 50%;
   background: var(--card-bg);
   border: 2px solid var(--input-border);
   cursor: pointer;
   display: flex;
   align-items: center;
   justify-content: center;
   box-shadow: 0 2px 8px var(--card-shadow);
   transition: all 0.3s ease;
   z-index: 1000;
}
.theme-toggle:hover {
   transform: scale(1.1);
   box-shadow: 0 4px 12px var(--card-shadow);
}
.theme-toggle svg {
   width: 24px;
   height: 24px;
   fill: var(--text);
   transition: transform 0.3s ease;
}
.theme-toggle:hover svg {
   transform: rotate(20deg);
}
 .graph-container{flex:1 1 600px;min-width:280px;display:flex;justify-content:center;align-items:stretch;padding-top:0;}
 .graph-card{
   background: var(--card-bg);
   /* base padding + reserved space for a possible vertical slider to avoid layout shift */
   padding: 20px;
   padding-right: calc(20px + var(--vslider-space));
   border-radius: 8px;
   box-shadow: 0 2px 4px var(--card-shadow);
   border: 1px solid var(--card-border);
   width: 100%;
   max-width: 708px; /* 620px canvas + 20px left padding + 68px right padding (20 + 48) */
   box-sizing: border-box;
   display: flex;
   align-items: center;
   justify-content: center;
   height: 100%;
   position: relative;
}
 .graph-card canvas{
   background:var(--card-bg);
   border:none;
   display:block;
   width: 620px;
   height: 420px;
   max-width: 100%;
   max-height: 100%;
}
 @media(max-width:800px){
   .graph-container,.info-container{flex:1 1 100%;}
   .graph-card{padding-right:20px;max-width:100%;} /* Remove reserved space on mobile */
 }
 @media(max-width:500px){
   .graph-card{padding:12px;}
 }</style>
</head>
<body>
<button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
  <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="moon-icon" style="display:none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>
<h1>Friction Lab Simulation</h1>
<div class="container">
 <div class="info-container">
  <div class="controls">
   <div class="controls-row inline-row">
    <label for="surface" class="inline-label">Surface Type</label>
    <select id="surface" class="inline-select">
     <option value="1.0,0.80">Rubber on Concrete</option>
     <option value="0.3,0.25">Rubber on Wet Concrete</option>
     <option value="0.05,0.03">Steel on Ice</option>
     <option value="0.60,0.50">Leather on Wood</option>
     <option value="0.45,0.30">Wood on Wood</option>
     <option value="0.04,0.02">Wood on Ice</option>
     <option value="0.65,0.55">Rubber on Wood</option>
     <option value="0.74,0.57">Steel on Steel (dry)</option>
     <option value="custom">Custom Surface</option>
    </select>
   </div>
    <div class="controls-row" id="customCoeffs" style="display:none;flex-direction:row;align-items:center;justify-content:center;gap:24px;">
         <div style="display:flex;align-items:center;gap:8px;">
            <label for="customStatic" style="margin:0;font-weight:600;color:var(--text-secondary);">Static:</label>
            <input type="number" id="customStatic" min="0" max="2" step="0.01" value="0.50" style="width:80px;" disabled>
         </div>
         <div style="display:flex;align-items:center;gap:8px;">
            <label for="customKinetic" style="margin:0;font-weight:600;color:var(--text-secondary);">Kinetic:</label>
            <input type="number" id="customKinetic" min="0" max="2" step="0.01" value="0.40" style="width:80px;" disabled>
         </div>
      </div>
      <div class="controls-row mass-row inline-row" style="align-items:center;">
         <label for="mass" class="inline-label" style="margin-right:8px;">Mass</label>
         <div class="mass-controls" style="flex:1 1 auto;">
             <input type="number" id="massInput" class="mass-input" min="0.100" max="2.000" step="0.001" value="0.100">
             <span>kg</span>
             <input type="range" id="mass" min="100" max="2000" step="1" value="100" class="inline-range">
         </div>
      </div>
   <div class="controls-row">
    <button id="startBtn" class="action">Start Simulation</button>
    <button id="resetBtn" class="action" disabled>Reset</button>
   </div>
   </div>
   <div class="readout">
      <span class="readout-label">LIVE APPLIED FORCE</span>
      <div id="forceReadout">0.00&nbsp;N</div>
   </div>
  <div class="results" id="results">
    <div class="results-heading">Measurement Results</div>
    <div class="awaiting-data">Awaiting simulation data...</div>
  </div>
 </div>
 <div class="graph-container">
   <div class="graph-card">
      <canvas id="graph" width="620" height="420"></canvas>
   </div>
 </div>
</div>
<script>
(()=>{
 // === DOM ===
 const g=9.8;
 const surfaceSel=document.getElementById('surface');
 const customCoeffs=document.getElementById('customCoeffs');
 const customStatic=document.getElementById('customStatic');
 const customKinetic=document.getElementById('customKinetic');
 const massSlider=document.getElementById('mass');
 const startBtn=document.getElementById('startBtn');
 const resetBtn=document.getElementById('resetBtn');
 const forceReadout=document.getElementById('forceReadout');
 const resultsDiv=document.getElementById('results');
 const canvas=document.getElementById('graph');
 const ctx=canvas.getContext('2d');

 // === High DPI Support ===
 function setupHiDPI() {
    const dpr = window.devicePixelRatio || 1;
    // Measure the canvas CSS size (already constrained by .graph-card)
    const rect = canvas.getBoundingClientRect();
    const cssWidth = Math.round(rect.width);
    const cssHeight = Math.round(rect.height);
    // Set the internal pixel size for crisp rendering
    canvas.width = cssWidth * dpr;
    canvas.height = cssHeight * dpr;
    // Reset any existing transforms and scale once
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return {dpr, cssWidth, cssHeight};
 }
 
 // Initial setup
 let setupResult = setupHiDPI();
 let dpr = setupResult.dpr;

 // === Layout - Dynamic calculation ===
 function getLayoutDimensions() {
    const canvasRect = canvas.getBoundingClientRect();
    const CANVAS_W = canvasRect.width;
    const CANVAS_H = canvasRect.height;
    const AX = 60;
    const TOP = 20;
    const BOTTOM = CANVAS_H - 40;
    const RIGHT = CANVAS_W - 20;
    const GRAPH_W = RIGHT - AX;
    const GRAPH_H = BOTTOM - TOP;
    return {CANVAS_W, CANVAS_H, AX, TOP, BOTTOM, RIGHT, GRAPH_W, GRAPH_H};
 }
 
 let layout = getLayoutDimensions();
 let {CANVAS_W, CANVAS_H, AX, TOP, BOTTOM, RIGHT, GRAPH_W, GRAPH_H} = layout;

 // === Simulation parameters ===
 const dt=0.05;
 const forceRamp=0.1;
 const noiseMag=0.05; // Adjust this value slightly (e.g., 0.03) for more pronounced variation if desired
 const POST_MOVE_TIME=4;
 const MAX_TOTAL_TIME=30;

 // === State ===
 let timer=null;
 let data=[];
 let t=0;
 let Fs_max=0, Fk=0; // Theoretical values (used for triggering movement)
 let moving=false;
 let tMoveStart=null;
 let endTime=MAX_TOTAL_TIME;
 let appliedForce=0;
 let timeSpan=8;

 // === Mass UI ===
 const massInput = document.getElementById('massInput');
 
 function updateFromSlider() {
    const massKg = (massSlider.value/1000).toFixed(3);
    massInput.value = massKg;
 }
 
 function updateFromInput() {
    const massKg = parseFloat(massInput.value);
    if (!isNaN(massKg) && massKg >= 0.1 && massKg <= 2.0) {
        massSlider.value = Math.round(massKg * 1000);
    }
 }
 
 // Initialize with default value
 updateFromSlider();
 
 // Add event listeners
 massSlider.addEventListener('input', updateFromSlider);
 massInput.addEventListener('input', updateFromInput);
 
// === Surface UI ===
surfaceSel.addEventListener('change', () => {
   const isCustom = surfaceSel.value === 'custom';
   customCoeffs.style.display = isCustom ? 'flex' : 'none';
   // Enable custom inputs only when 'custom' is selected and simulation is not running
   customStatic.disabled = !isCustom || startBtn.disabled;
   customKinetic.disabled = !isCustom || startBtn.disabled;
});

 // === Utility ===
 function niceStep(max){
  const raw=max/5;
  const pow=10**Math.floor(Math.log10(raw));
  for(const m of [1,2,5,10]) if(m*pow>=raw) return m*pow;
  return pow*10;
 }

 // Draw axes & grid (No changes needed here)
 function drawAxes(maxF){
    // Update layout dimensions in case canvas was resized
    layout = getLayoutDimensions();
    ({CANVAS_W, CANVAS_H, AX, TOP, BOTTOM, RIGHT, GRAPH_W, GRAPH_H} = layout);
    
    const stepY=niceStep(maxF);
    const yMax=Math.ceil(maxF/stepY)*stepY;
    const stepX=1;
    const xScale=GRAPH_W/timeSpan;
    const yScale=GRAPH_H/yMax;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Get theme colors from CSS variables
    const styles = getComputedStyle(document.documentElement);
    const gridMinor = styles.getPropertyValue('--grid-minor').trim() || '#ccc';
    const gridLight = styles.getPropertyValue('--grid-light').trim() || '#eee';
    const gridMajor = styles.getPropertyValue('--grid-major').trim() || '#000';
    
    ctx.lineWidth=1;
    for(let f=0;f<=yMax;f+=stepY){ ctx.strokeStyle=gridMinor; const y=BOTTOM-f*yScale; ctx.beginPath();ctx.moveTo(AX,y);ctx.lineTo(RIGHT,y);ctx.stroke(); }
    for(let f=stepY/2;f<yMax;f+=stepY){ ctx.strokeStyle=gridLight; const y=BOTTOM-f*yScale; ctx.beginPath();ctx.moveTo(AX,y);ctx.lineTo(RIGHT,y);ctx.stroke(); }
    for(let s=0;s<=timeSpan;s+=stepX){ const x=AX+s*xScale; ctx.strokeStyle=s%1===0?gridMinor:gridLight; ctx.beginPath();ctx.moveTo(x,TOP);ctx.lineTo(x,BOTTOM);ctx.stroke(); }
    // Draw main axes with slightly thicker lines
    ctx.strokeStyle=gridMajor; 
    ctx.lineWidth=1.5; 
    ctx.beginPath();
    ctx.moveTo(AX,TOP);
    ctx.lineTo(AX,BOTTOM);
    ctx.lineTo(RIGHT,BOTTOM);
    ctx.stroke();

    // Use system font matching the UI
    const fontFamily = '"Segoe UI","Helvetica Neue",Arial,sans-serif';
    ctx.font = `12px ${fontFamily}`; 
    ctx.fillStyle=gridMajor; 
    ctx.textAlign='center';

    // Crisp text rendering
    ctx.textBaseline = 'middle';
    
    // Axis labels
    ctx.fillText('Time (s)',(AX+RIGHT)/2,BOTTOM+28);
    ctx.save(); 
    ctx.translate(AX-38,TOP+GRAPH_H/2); 
    ctx.rotate(-Math.PI/2); 
    ctx.fillText('Force (N)',0,0); 
    ctx.restore();
    
    // Time markers
    for(let s=0;s<=timeSpan;s+=stepX){ 
        const x=AX+s*xScale; 
        ctx.fillText(s.toString(),x,BOTTOM+15); 
    }
    
    // Force markers
    ctx.textAlign='right'; 
    const fmt=stepY<1?(v)=>v.toFixed(1):(v)=>v.toFixed(0);
    for(let f=0;f<=yMax+1e-6;f+=stepY){ 
        const y=BOTTOM-f*yScale; 
        ctx.fillText(fmt(f),AX-5,y);
    }
    return {xScale,yScale};
 }

 function plotData(){
    const maxF=Math.max(1,...data.map(d=>d.force));
    const scales=drawAxes(maxF);
    if(data.length<2) return;
   // Draw data line with improved crispness
   const styles = getComputedStyle(document.documentElement);
   ctx.strokeStyle = styles.getPropertyValue('--primary') || '#007acc';
   ctx.lineWidth = 2; // context already scaled for DPR
   
   // Add glow effect in dark mode
   const isDark = document.documentElement.classList.contains('dark-mode');

if (isDark) {
    ctx.lineWidth = 2;
    ctx.shadowBlur = 26;
    ctx.shadowColor = 'rgba(0, 200, 255, 1)';
    ctx.strokeStyle = 'rgba(0, 200, 255, 1)';
} else {
    ctx.shadowBlur = 0;
}
   
    ctx.beginPath();
    
    // Align to pixel grid for sharper lines
    data.forEach((d,i)=>{ 
   const x = AX + d.time * scales.xScale;
   const y = BOTTOM - d.force * scales.yScale;
        if(i===0) ctx.moveTo(x,y); 
        else ctx.lineTo(x,y); 
    });
    
    ctx.stroke();
    
    // Reset shadow for other drawing operations
    ctx.shadowBlur = 0;
 }

 // === Simulation loop ===
 function step(){
    t+=dt;
    if(!moving){
        appliedForce+=forceRamp;
        // Check includes noise, causing tMoveStart to vary slightly each run
        if(appliedForce + (Math.random()-0.5)*2*noiseMag >= Fs_max){
            moving=true;
            tMoveStart=t;
            endTime=t+POST_MOVE_TIME;
            appliedForce=Fk; // Base force drops to theoretical kinetic
            // *** DEBUG: Log the exact time movement starts ***
            console.log(`Movement started at t = ${tMoveStart.toFixed(3)} s`);
        }
    } else {
        appliedForce=Fk; // Base force is theoretical kinetic
    }

    if(t > timeSpan - 0.5) {
        timeSpan = Math.ceil(t + 1);
    }

    // Apply noise for this step's measurement
    const noisyForce = appliedForce + (Math.random() - 0.5) * 2 * noiseMag;
    data.push({time:t, force:Math.max(0, noisyForce)});
    // *** CHANGE: Display live force to 2 decimal places ***
    forceReadout.innerHTML = `${noisyForce.toFixed(2)}&nbsp;N`;
    plotData();

    if(t>=endTime || t>=MAX_TOTAL_TIME) {
        endSimulation();
    }
 }

 // === Control helpers ===
 function setUI(running){
    startBtn.disabled=running;
    resetBtn.disabled=!running;
    surfaceSel.disabled=running;
    massSlider.disabled=running;
    massInput.disabled=running;
   // Also manage custom coeff inputs: only enabled when custom is selected and not running
   const isCustom = surfaceSel.value === 'custom';
   customStatic.disabled = !isCustom || running;
   customKinetic.disabled = !isCustom || running;
 }

 function resetSimulation(){
    if(timer){ clearInterval(timer); timer=null; }
    data=[]; t=0; moving=false; appliedForce=0; tMoveStart=null; endTime=MAX_TOTAL_TIME; timeSpan=8;
    // Reset readout and results to default state
    forceReadout.innerHTML='0.00&nbsp;N';
    resultsDiv.innerHTML = `
        <div class="results-heading">Measurement Results</div>
        <div class="awaiting-data">Awaiting simulation data...</div>
    `;
    setUI(false);
    plotData();
 }

 function endSimulation(){
     if(timer){
         clearInterval(timer);
         timer = null;
         setUI(false);

         let measured_Fs_max = 0;
         let measured_Fk = 0;
         let kineticDataCount = 0;
         let kineticSum = 0;

         // Analyze the collected noisy data
         if (data.length > 0) {
             // Find measured max static friction (peak force before tMoveStart, or overall peak if no movement)
             const staticPhaseData = data.filter(d => tMoveStart === null || d.time < tMoveStart);
             if (staticPhaseData.length > 0) {
                 measured_Fs_max = Math.max(...staticPhaseData.map(d => d.force));
             } else if (!moving && data.length > 0) {
                 measured_Fs_max = Math.max(...data.map(d => d.force));
             } else {
                  // Fallback for instant movement or edge cases (could use data[0].force)
                  measured_Fs_max = (data.length > 0) ? data[0].force : 0; // Use first point if available
             }


             // Calculate measured average kinetic friction (average force at or after tMoveStart)
             if (moving && tMoveStart !== null) {
                 const kineticPhaseData = data.filter(d => d.time >= tMoveStart);
                 kineticDataCount = kineticPhaseData.length;
                 if (kineticDataCount > 0) {
                     kineticSum = kineticPhaseData.reduce((sum, d) => sum + d.force, 0);
                     measured_Fk = kineticSum / kineticDataCount;
                 }
                 // If kineticDataCount is 0 (shouldn't happen normally), measured_Fk remains 0
             }
             // If !moving, measured_Fk remains 0
         }
         // If data.length is 0, both measured values remain 0


         // *** DEBUG: Log the raw measured values before rounding ***
         console.log(`Measured Fs (raw): ${measured_Fs_max}`);
         console.log(`Measured Fk (raw): ${measured_Fk} (from ${kineticDataCount} points)`);

         // Display results
         resultsDiv.innerHTML = `
            <div class="results-heading">Measurement Results</div>
            <div class="result-row">
               <div class="result-label" style="color:#1a73e8;font-weight:500;">Peak Static Friction (F<sub>s,max</sub>):</div>
               <div class="result-value">${measured_Fs_max.toFixed(2)} N</div>
            </div>
            <div class="result-row">
               <div class="result-label" style="color:var(--accent);font-weight:500;">Average Kinetic Friction (F<sub>k</sub>):</div>
               <div class="result-value">${moving && kineticDataCount > 0 ? measured_Fk.toFixed(2) + ' N' : 'N/A'}</div>
            </div>
         `;


         // The forceReadout still shows the last noisy value from step()
     }
 }


 function startSimulation(){
    resetSimulation();
    let mus, muk;
    if (surfaceSel.value === 'custom') {
        mus = parseFloat(customStatic.value);
        muk = parseFloat(customKinetic.value);
    } else {
        [mus, muk] = surfaceSel.value.split(',').map(Number);
    }
    const massKg=massSlider.value/1000; const FN=massKg*g;
    // Store theoretical values (still needed for physics logic)
    Fs_max=mus*FN;
    Fk=muk*FN;
    setUI(true);
    timer=setInterval(step,dt*1000);
 }

 // === Event wiring ===
 startBtn.addEventListener('click',startSimulation);
 resetBtn.addEventListener('click',resetSimulation);

 // === Theme Toggle ===
 const themeToggle = document.getElementById('themeToggle');
 const sunIcon = themeToggle.querySelector('.sun-icon');
 const moonIcon = themeToggle.querySelector('.moon-icon');
 
 // Check for saved theme preference or default to light mode
 const savedTheme = localStorage.getItem('theme') || 'light';
 if (savedTheme === 'dark') {
    document.documentElement.classList.add('dark-mode');
    sunIcon.style.display = 'none';
    moonIcon.style.display = 'block';
 }
 
 themeToggle.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark-mode');
    const isDark = document.documentElement.classList.contains('dark-mode');
    
    if (isDark) {
        sunIcon.style.display = 'none';
        moonIcon.style.display = 'block';
        localStorage.setItem('theme', 'dark');
    } else {
        sunIcon.style.display = 'block';
        moonIcon.style.display = 'none';
        localStorage.setItem('theme', 'light');
    }
    
    // Redraw the graph with new theme colors
    plotData();
 });

 // Initial plot - draw after theme is set
 plotData(); // Draw the initial empty axes with 0.00 readout
 
 // === Responsive resize handler ===
 let resizeTimeout;
 window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        // Recalculate canvas size and DPI
        setupResult = setupHiDPI();
        dpr = setupResult.dpr;
        // Redraw graph with new dimensions
        plotData();
    }, 150); // Debounce resize events
 });
})();
</script>
</body>
</html>